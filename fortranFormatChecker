#!/usr/bin/perl
#
#   This script is used to check blocking and indenting in fortran
#   programs.
#
#   Initial Completion Date:       5/31/2020
#   Most Recent Modification Date: 5/31/2020
#
#                  Hrant P. Hratchian
#                  Department of Chemistry & Chemical Biology
#                  University of California, Merced
#                  hhratchian@ucmerced.edu
#


##########################################################################
#                                                                        #
#                               MAIN CODE                                #
#                                                                        #
##########################################################################

#
#   Interpret command line arguments and get the list of source code files
#   to process.
#
    foreach(@ARGV){
      chomp($_);
      if(/^-(.*)/){
        die "Unknown argument sent to fortranBlocking: $1\n\n";
      }else {
        push(@srcFiles,$_);
      }
    }
    %rules = &set_rules();
#
#   Go through the source code files, one by one.
#
    foreach $currentSrcFile (@srcFiles){
      print "Processing source file $currentSrcFile\n";
      $numberOfLines = &process_srcFile($currentSrcFile,%rules);
      print "\tDONE processing file...Number of lines = $numberOfLines\n\n";
    }
#
#   All Done!
#
    print "All Done!\n";


##########################################################################
#                                                                        #
#                              SUBROUTINES                               #
#                                                                        #
##########################################################################

    sub process_srcFile{
#
#     This routine takes a scalar with the name of a source code file. This
#     code then processes that file. The output of this routine is an
#     integer giving the number of lines with issues.
#
      use strict;
      my($filename,%rules) = @_;
      my($currentLine,$currentLineIndent,$lineIndent,$lineNumberActual,  
        $lineNumberCoded);
      my($DEBUG,$lineIndent,$trimmedLine,$incrementCurrent,$incrementNext,
        @warningListTemp,@warningList,$nWarnings,$temp);
      $DEBUG = 0;
      chomp($filename);
#
#     Tell the user what's going on here...
#
      if($DEBUG){print "\n\tInside Routine process_srcFile...file=$filename\n\n"}
#
#     Grab a few key rules from the rules hash table.
#
      $currentLineIndent = $rules{"standardlineindent"};
#
#
#     Open the source code file and then begin processing it.
#
      open SRCFILE,"$filename";
      $lineNumberActual = 0;
      while(<SRCFILE>){
        $currentLine = $_;
        chomp($currentLine);
        $lineNumberActual += 1;
        ($lineIndent,$trimmedLine) = &remove_lineNumberSpace($currentLine);
        if($DEBUG){
          print "\n--->$currentLine<---\n--->$trimmedLine<---\nIndent = $lineIndent\n\n";
        }
        ($incrementCurrent,$incrementNext,@warningListTemp) = 
          &incrementForLine($lineNumberActual,$trimmedLine,%rules);
        push(@warningList,@warningListTemp);
        if(($lineIndent-$currentLineIndent) ne $incrementCurrent){
          push(@warningList,"Line $lineNumberActual: Incorrect indentation/blocking.");
        }
        $currentLineIndent += $incrementNext;
      }
      close SRCFILE,"$filename";
#
#     Report the result of the check of this current source code file.
#
      print "\tFile $filename";
      $nWarnings = @warningList;
      if(@warningList){
        print " has $nWarnings WARNINGS.\n";
        foreach $temp (@warningList){
          chomp($temp);
          print "\t$temp\n";
        }
      }else{
        print " passed all tests.\n";
      }
#
      return $lineNumberActual;
    }

    sub set_rules{
#
#     This routine sets up the rules hash, which is used to control how
#     thee program tests for and enforces formatting and syntax as it
#     processes source code files.
#
#     There are NO input arguments. The rules hash is the only output
#     argument.
#
#     The list of rules is given in the table below. Default values for
#     each rule is given in a second table afterwards.
#
#     ----------------------------------------------------------------
#     Rule                      Comment
#     ----------------------------------------------------------------
#     standardLineIndent        This is the number of columns a
#                               standard line should be indented.
#
#     indent                    This is the number of spaces to indent
#                               code blocks when appropriate.
#
#     endDoWithBlock            This is TRUE or FALSE to indicate whether
#                               an endDo statement should block with the
#                               code above it or move back. In either case,
#                               the next line indentation will deincrement.
#
#     endIfWithBlock            This is TRUE or FALSE to indicate whether
#                               an endIf statement should block with the
#                               code above it or move back. In either case,
#                               the next line indentation will deincrement.
#
#     continueWithBlock         This is TRUE or FALSE to indicate whether
#                               an Continue statement should block with the
#                               code above it or move back. In either case,
#                               the next line indentation will deincrement.
#
#     doIndent                  This is the indentation applied to blocks
#                               of Do loops. It defaults to the value given
#                               <indent>.
#
#     ifIndent                  This is the indentation applied to if/then
#                               blocks It defaults to the value given
#                               <indent>.
#     ================================================================
#
#     ----------------------------------------------------------------
#     Rule                      Default Value
#     ----------------------------------------------------------------
#     standardLineIndent        6
#     indent                    2
#     endDoWithBlock            FALSE (0)
#     endIfWithBlock            FALSE (0)
#     continueWithBlock         FALSE (0)
#     doIndent                  2
#     ifIndent                  2
#     ================================================================
#
#
      use strict;
      my(%rules);
#
#     Hardwire the general rules in the hash.
#
      $rules{standardlineindent} = 6;
      $rules{indent}             = 2;
      $rules{endifwithblock}     = 0;
      $rules{enddowithblock}     = 0;
      $rules{continuewithblock}  = 0;
#
#     Copy the general indentation amount to the different blocks.
#
      unless($rules{indentdo}){$rules{indentdo} = $rules{indent}};
      unless($rules{indentif}){$rules{indentif} = $rules{indent}};
#
      return %rules;
    }

    sub process_line{
#
#     This routine processes a single line of code and determines what its
#     change in indentation should be and what the change in indentation
#     should be for the next line.
#
#     There are two INPUT arguments: (1) the line to process; and (2) the
#     rules hash.
#
#     There are two OUTPUT arguments: (1) the indentation increment that
#     should be applied to this line; and (2) the indentation increment
#     that should be applied to the next line.
#
#
      use strict;
      my($line,%rules) = @_;
      my($lineType);
#
#     Determine the line type of the line being read. Hardwire the rules hash.
#
      $rules{standardlineindent} = 7;
      $rules{indent}             = 2;
#
      return %rules;
    }

    sub incrementForLine{
#
#     This routine determines the increment that should expected for the
#     current line and the next line wrt the previous line's increment.
#
#     There are two INPUT arguments: (1) the current line number in the
#     source code file; and (2)the current line after being trimmed by
#     Routine remove_lineNumberSpace.
#
#     There are three OUTPUT arguments: (1) the number of spaces the current
#     line should be incremented; (2) the number of spaces the next
#     line should be incremented; and (3) a list of warnings generated in
#     this routine.
#
#
      use strict;
      my($lineNumber,$line,%rules) = @_;
      my($incrementCurrent,$incrementNext,@warningList);
      my($DEBUG);
      $DEBUG = 0;
#
#     Look at the line sent in to determine if it's a special kind of line.
#     If so, check the rules to determine indentation increments for this
#     line and the next one.
#
      if($DEBUG){print "\n\n\t\tInside incrementForLine: line = $line.\n"}
      if($line =~ /^(do .*||do)$/i){
        if($DEBUG){print "\tFound DO line.\n"};
        $incrementCurrent = 0;
        $incrementNext    = $rules{indentdo};
      }elsif($line =~ /^enddo *$/i){
        if($DEBUG){print "\tFound ENDDO line.\n"};
        if($rules{enddowithblock}){
          $incrementCurrent = 0;
        }else{
          $incrementCurrent = -$rules{indentdo};
        }
        $incrementNext = -$rules{indentdo};
      }else{
        if($DEBUG){print "\tFound nominal line.\n"};
        $incrementCurrent = 0;
        $incrementNext    = 0;
      }
#
      if($DEBUG){
        print "\t\tincrementCurrent = $incrementCurrent\n";
        print "\t\tincrementNext    = $incrementNext\n";
      }
      return($incrementCurrent,$incrementNext,@warningList);
    }

    sub remove_lineNumberSpace{
#
#     This routine removes a line numbers and leading spaces from a line of code.
#
#     There is one INPUT arguments: the line to be processed.
#
#     There is one OUTPUT arguments: the processed line with leading spaces
#     and line numbers removed.
#
#
      use strict;
      my($line) = @_;
      my($leadingSpaces,$lineNumber);
      my($DEBUG,$lineIndent,$trimmedLine);
      $DEBUG = 0;
#
#     Remove leading spaces and line numbers from the line sent.
#
      if($DEBUG){print "\n\n\t\tInside remove_lineNumbreSpace: line = $line.\n"}
      if($line =~ /^([\s\d]+)([a-zA-Z].*)\s*$/){
        if($DEBUG){print "MATCH 1\n"};
        $leadingSpaces = $1;
        $trimmedLine = $2;
        $lineIndent = length($leadingSpaces);
        $lineNumber = $leadingSpaces;
        $lineNumber =~ s/\s//g;
      }elsif($line =~ /^(\s*)([a-zA-Z].*)\s*$/){
        if($DEBUG){print "MATCH 2\n"};
        $leadingSpaces = $1;
        $trimmedLine = $2;
        $lineIndent = length($leadingSpaces);
      }else{
        if($DEBUG){print "MATCH 3\n"};
        $trimmedLine = " ";
        $lineIndent = -1;
      }
#
      return ($lineIndent,$trimmedLine);
    }
